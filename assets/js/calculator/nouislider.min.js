/*! nouislider - 8.3.0 - 2016-02-14 17:37:19 */

!(function (a) { typeof define === 'function' && define.amd ? define([], a) : typeof exports === 'object' ? module.exports = a() : window.noUiSlider = a(); }(() => {
  function a(a) { return a.filter(function (a) { return this[a] ? !1 : this[a] = !0; }, {}); } function b(a, b) { return Math.round(a / b) * b; } function c(a) { const b = a.getBoundingClientRect(); const c = a.ownerDocument; const d = c.documentElement; const e = m(); return /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (e.x = 0), { top: b.top + e.y - d.clientTop, left: b.left + e.x - d.clientLeft }; } function d(a) { return typeof a === 'number' && !isNaN(a) && isFinite(a); } function e(a) { const b = Math.pow(10, 7); return Number((Math.round(a * b) / b).toFixed(7)); } function f(a, b, c) { j(a, b), setTimeout(() => { k(a, b); }, c); } function g(a) { return Math.max(Math.min(a, 100), 0); } function h(a) { return Array.isArray(a) ? a : [a]; } function i(a) { const b = a.split('.'); return b.length > 1 ? b[1].length : 0; } function j(a, b) { a.classList ? a.classList.add(b) : a.className += ` ${b}`; } function k(a, b) { a.classList ? a.classList.remove(b) : a.className = a.className.replace(new RegExp(`(^|\\b)${b.split(' ').join('|')}(\\b|$)`, 'gi'), ' '); } function l(a, b) { return a.classList ? a.classList.contains(b) : new RegExp(`\\b${b}\\b`).test(a.className); } function m() { const a = void 0 !== window.pageXOffset; const b = (document.compatMode || '') === 'CSS1Compat'; const c = a ? window.pageXOffset : b ? document.documentElement.scrollLeft : document.body.scrollLeft; const d = a ? window.pageYOffset : b ? document.documentElement.scrollTop : document.body.scrollTop; return { x: c, y: d }; } function n(a) { a.stopPropagation(); } function o(a) { return function (b) { return a + b; }; } function p(a, b) { return 100 / (b - a); } function q(a, b) { return 100 * b / (a[1] - a[0]); } function r(a, b) { return q(a, a[0] < 0 ? b + Math.abs(a[0]) : b - a[0]); } function s(a, b) { return b * (a[1] - a[0]) / 100 + a[0]; } function t(a, b) { for (var c = 1; a >= b[c];)c += 1; return c; } function u(a, b, c) { if (c >= a.slice(-1)[0]) return 100; let d; let e; let f; let g; const h = t(c, a); return d = a[h - 1], e = a[h], f = b[h - 1], g = b[h], f + r([d, e], c) / p(f, g); } function v(a, b, c) { if (c >= 100) return a.slice(-1)[0]; let d; let e; let f; let g; const h = t(c, b); return d = a[h - 1], e = a[h], f = b[h - 1], g = b[h], s([d, e], (c - f) * p(f, g)); } function w(a, c, d, e) { if (e === 100) return e; let f; let g; const h = t(e, a); return d ? (f = a[h - 1], g = a[h], e - f > (g - f) / 2 ? g : f) : c[h - 1] ? a[h - 1] + b(e - a[h - 1], c[h - 1]) : e; } function x(a, b, c) { let e; if (typeof b === 'number' && (b = [b]), Object.prototype.toString.call(b) !== '[object Array]') throw new Error("noUiSlider: 'range' contains invalid value."); if (e = a === 'min' ? 0 : a === 'max' ? 100 : parseFloat(a), !d(e) || !d(b[0])) throw new Error("noUiSlider: 'range' value isn't numeric."); c.xPct.push(e), c.xVal.push(b[0]), e ? c.xSteps.push(isNaN(b[1]) ? !1 : b[1]) : isNaN(b[1]) || (c.xSteps[0] = b[1]); } function y(a, b, c) { return b ? void (c.xSteps[a] = q([c.xVal[a], c.xVal[a + 1]], b) / p(c.xPct[a], c.xPct[a + 1])) : !0; } function z(a, b, c, d) { this.xPct = [], this.xVal = [], this.xSteps = [d || !1], this.xNumSteps = [!1], this.snap = b, this.direction = c; let e; const f = []; for (e in a)a.hasOwnProperty(e) && f.push([a[e], e]); for (f.length && typeof f[0][0] === 'object' ? f.sort((a, b) => a[0][0] - b[0][0]) : f.sort((a, b) => a[0] - b[0]), e = 0; e < f.length; e++)x(f[e][1], f[e][0], this); for (this.xNumSteps = this.xSteps.slice(0), e = 0; e < this.xNumSteps.length; e++)y(e, this.xNumSteps[e], this); } function A(a, b) { if (!d(b)) throw new Error("noUiSlider: 'step' is not numeric."); a.singleStep = b; } function B(a, b) { if (typeof b !== 'object' || Array.isArray(b)) throw new Error("noUiSlider: 'range' is not an object."); if (void 0 === b.min || void 0 === b.max) throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'."); if (b.min === b.max) throw new Error("noUiSlider: 'range' 'min' and 'max' cannot be equal."); a.spectrum = new z(b, a.snap, a.dir, a.singleStep); } function C(a, b) { if (b = h(b), !Array.isArray(b) || !b.length || b.length > 2) throw new Error("noUiSlider: 'start' option is incorrect."); a.handles = b.length, a.start = b; } function D(a, b) { if (a.snap = b, typeof b !== 'boolean') throw new Error("noUiSlider: 'snap' option must be a boolean."); } function E(a, b) { if (a.animate = b, typeof b !== 'boolean') throw new Error("noUiSlider: 'animate' option must be a boolean."); } function F(a, b) { if (b === 'lower' && a.handles === 1)a.connect = 1; else if (b === 'upper' && a.handles === 1)a.connect = 2; else if (b === !0 && a.handles === 2)a.connect = 3; else { if (b !== !1) throw new Error("noUiSlider: 'connect' option doesn't match handle count."); a.connect = 0; } } function G(a, b) { switch (b) { case 'horizontal': a.ort = 0; break; case 'vertical': a.ort = 1; break; default: throw new Error("noUiSlider: 'orientation' option is invalid."); } } function H(a, b) { if (!d(b)) throw new Error("noUiSlider: 'margin' option must be numeric."); if (b !== 0 && (a.margin = a.spectrum.getMargin(b), !a.margin)) throw new Error("noUiSlider: 'margin' option is only supported on linear sliders."); } function I(a, b) { if (!d(b)) throw new Error("noUiSlider: 'limit' option must be numeric."); if (a.limit = a.spectrum.getMargin(b), !a.limit) throw new Error("noUiSlider: 'limit' option is only supported on linear sliders."); } function J(a, b) { switch (b) { case 'ltr': a.dir = 0; break; case 'rtl': a.dir = 1, a.connect = [0, 2, 1, 3][a.connect]; break; default: throw new Error("noUiSlider: 'direction' option was not recognized."); } } function K(a, b) {
    if (typeof b !== 'string') throw new Error("noUiSlider: 'behaviour' must be a string containing options."); const c = b.indexOf('tap') >= 0; const d = b.indexOf('drag') >= 0; const e = b.indexOf('fixed') >= 0; const f = b.indexOf('snap') >= 0; const g = b.indexOf('hover') >= 0; if (d && !a.connect) throw new Error("noUiSlider: 'drag' behaviour must be used with 'connect': true."); a.events = {
      tap: c || f, drag: d, fixed: e, snap: f, hover: g,
    };
  } function L(a, b) { let c; if (b !== !1) if (b === !0) for (a.tooltips = [], c = 0; c < a.handles; c++)a.tooltips.push(!0); else { if (a.tooltips = h(b), a.tooltips.length !== a.handles) throw new Error('noUiSlider: must pass a formatter for all handles.'); a.tooltips.forEach((a) => { if (typeof a !== 'boolean' && (typeof a !== 'object' || typeof a.to !== 'function')) throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'."); }); } } function M(a, b) { if (a.format = b, typeof b.to === 'function' && typeof b.from === 'function') return !0; throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods."); } function N(a, b) { if (void 0 !== b && typeof b !== 'string') throw new Error("noUiSlider: 'cssPrefix' must be a string."); a.cssPrefix = b; } function O(a) {
    let b; const c = {
      margin: 0, limit: 0, animate: !0, format: T,
    }; b = {
      step: { r: !1, t: A }, start: { r: !0, t: C }, connect: { r: !0, t: F }, direction: { r: !0, t: J }, snap: { r: !1, t: D }, animate: { r: !1, t: E }, range: { r: !0, t: B }, orientation: { r: !1, t: G }, margin: { r: !1, t: H }, limit: { r: !1, t: I }, behaviour: { r: !0, t: K }, format: { r: !1, t: M }, tooltips: { r: !1, t: L }, cssPrefix: { r: !1, t: N },
    }; const d = {
      connect: !1, direction: 'ltr', behaviour: 'tap', orientation: 'horizontal',
    }; return Object.keys(b).forEach((e) => { if (void 0 === a[e] && void 0 === d[e]) { if (b[e].r) throw new Error(`noUiSlider: '${e}' is required.`); return !0; }b[e].t(c, void 0 === a[e] ? d[e] : a[e]); }), c.pips = a.pips, c.style = c.ort ? 'top' : 'left', c;
  } function P(b, d) {
    function e(a, b, c) { let d = a + b[0]; let e = a + b[1]; return c ? (d < 0 && (e += Math.abs(d)), e > 100 && (d -= e - 100), [g(d), g(e)]) : [d, e]; } function p(a, b) { a.preventDefault(); let c; let d; const e = a.type.indexOf('touch') === 0; const f = a.type.indexOf('mouse') === 0; let g = a.type.indexOf('pointer') === 0; const h = a; return a.type.indexOf('MSPointer') === 0 && (g = !0), e && (c = a.changedTouches[0].pageX, d = a.changedTouches[0].pageY), b = b || m(), (f || g) && (c = a.clientX + b.x, d = a.clientY + b.y), h.pageOffset = b, h.points = [c, d], h.cursor = f || g, h; } function q(a, b) { const c = document.createElement('div'); const d = document.createElement('div'); const e = ['-lower', '-upper']; return a && e.reverse(), j(d, da[3]), j(d, da[3] + e[b]), j(c, da[2]), c.appendChild(d), c; } function r(a, b, c) { switch (a) { case 1: j(b, da[7]), j(c[0], da[6]); break; case 3: j(c[1], da[6]); case 2: j(c[0], da[7]); case 0: j(b, da[6]); } } function s(a, b, c) { let d; const e = []; for (d = 0; a > d; d += 1)e.push(c.appendChild(q(b, d))); return e; } function t(a, b, c) { j(c, da[0]), j(c, da[8 + a]), j(c, da[4 + b]); const d = document.createElement('div'); return j(d, da[1]), c.appendChild(d), d; } function u(a, b) { if (!d.tooltips[b]) return !1; const c = document.createElement('div'); return c.className = da[18], a.firstChild.appendChild(c); } function v() { d.dir && d.tooltips.reverse(); const a = Y.map(u); d.dir && (a.reverse(), d.tooltips.reverse()), U('update', (b, c, e) => { a[c] && (a[c].innerHTML = d.tooltips[c] === !0 ? b[c] : d.tooltips[c].to(e[c])); }); } function w(a, b, c) { if (a === 'range' || a === 'steps') return aa.xVal; if (a === 'count') { let d; const e = 100 / (b - 1); let f = 0; for (b = []; (d = f++ * e) <= 100;)b.push(d); a = 'positions'; } return a === 'positions' ? b.map((a) => aa.fromStepping(c ? aa.getStep(a) : a)) : a === 'values' ? c ? b.map((a) => aa.fromStepping(aa.getStep(aa.toStepping(a)))) : b : void 0; } function x(b, c, d) { function e(a, b) { return (a + b).toFixed(7) / 1; } const f = aa.direction; const g = {}; const h = aa.xVal[0]; const i = aa.xVal[aa.xVal.length - 1]; let j = !1; let k = !1; let l = 0; return aa.direction = 0, d = a(d.slice().sort((a, b) => a - b)), d[0] !== h && (d.unshift(h), j = !0), d[d.length - 1] !== i && (d.push(i), k = !0), d.forEach((a, f) => { let h; let i; let m; let n; let o; let p; let q; let r; let s; let t; const u = a; const v = d[f + 1]; if (c === 'steps' && (h = aa.xNumSteps[f]), h || (h = v - u), u !== !1 && void 0 !== v) for (i = u; v >= i; i = e(i, h)) { for (n = aa.toStepping(i), o = n - l, r = o / b, s = Math.round(r), t = o / s, m = 1; s >= m; m += 1)p = l + m * t, g[p.toFixed(5)] = ['x', 0]; q = d.indexOf(i) > -1 ? 1 : c === 'steps' ? 2 : 0, !f && j && (q = 0), i === v && k || (g[n.toFixed(5)] = [i, q]), l = n; } }), aa.direction = f, g; } function y(a, b, c) { function e(a) { return ['-normal', '-large', '-sub'][a]; } function f(a, b, c) { return `class="${b} ${b}-${h} ${b}${e(c[1])}" style="${d.style}: ${a}%"`; } function g(a, d) { aa.direction && (a = 100 - a), d[1] = d[1] && b ? b(d[0], d[1]) : d[1], k += `<div ${f(a, da[21], d)}></div>`, d[1] && (k += `<div ${f(a, da[22], d)}>${c.to(d[0])}</div>`); } var h = ['horizontal', 'vertical'][d.ort]; const i = document.createElement('div'); var k = ''; return j(i, da[20]), j(i, `${da[20]}-${h}`), Object.keys(a).forEach((b) => { g(b, a[b]); }), i.innerHTML = k, i; } function z(a) { const b = a.mode; const c = a.density || 1; const d = a.filter || !1; const e = a.values || !1; const f = a.stepped || !1; const g = w(b, e, f); const h = x(c, b, g); const i = a.format || { to: Math.round }; return $.appendChild(y(h, d, i)); } function A() { const a = X.getBoundingClientRect(); const b = `offset${['Width', 'Height'][d.ort]}`; return d.ort === 0 ? a.width || X[b] : a.height || X[b]; } function B(a, b, c) { void 0 !== b && d.handles !== 1 && (b = Math.abs(b - d.dir)), Object.keys(ca).forEach((d) => { const e = d.split('.')[0]; a === e && ca[d].forEach((a) => { a.call(Z, h(P()), b, h(C(Array.prototype.slice.call(ba))), c || !1, _); }); }); } function C(a) { return a.length === 1 ? a[0] : d.dir ? a.reverse() : a; } function D(a, b, c, e) { const f = function (b) { return $.hasAttribute('disabled') ? !1 : l($, da[14]) ? !1 : (b = p(b, e.pageOffset), a === R.start && void 0 !== b.buttons && b.buttons > 1 ? !1 : e.hover && b.buttons ? !1 : (b.calcPoint = b.points[d.ort], void c(b, e))); }; const g = []; return a.split(' ').forEach((a) => { b.addEventListener(a, f, !1), g.push([a, f]); }), g; } function E(a, b) { if (navigator.appVersion.indexOf('MSIE 9') === -1 && a.buttons === 0 && b.buttonsProperty !== 0) return F(a, b); let c; let d; const f = b.handles || Y; let g = !1; const h = 100 * (a.calcPoint - b.start) / b.baseSize; const i = f[0] === Y[0] ? 0 : 1; if (c = e(h, b.positions, f.length > 1), g = L(f[0], c[i], f.length === 1), f.length > 1) { if (g = L(f[1], c[i ? 0 : 1], !1) || g) for (d = 0; d < b.handles.length; d++)B('slide', d); } else g && B('slide', i); } function F(a, b) { const c = X.querySelector(`.${da[15]}`); const d = b.handles[0] === Y[0] ? 0 : 1; c !== null && k(c, da[15]), a.cursor && (document.body.style.cursor = '', document.body.removeEventListener('selectstart', document.body.noUiListener)); const e = document.documentElement; e.noUiListeners.forEach((a) => { e.removeEventListener(a[0], a[1]); }), k($, da[12]), B('set', d), B('change', d), void 0 !== b.handleNumber && B('end', b.handleNumber); } function G(a, b) { a.type === 'mouseout' && a.target.nodeName === 'HTML' && a.relatedTarget === null && F(a, b); } function H(a, b) {
      const c = document.documentElement; if (b.handles.length === 1 && (j(b.handles[0].children[0], da[15]), b.handles[0].hasAttribute('disabled'))) return !1; a.preventDefault(), a.stopPropagation(); const d = D(R.move, c, E, {
        start: a.calcPoint, baseSize: A(), pageOffset: a.pageOffset, handles: b.handles, handleNumber: b.handleNumber, buttonsProperty: a.buttons, positions: [_[0], _[Y.length - 1]],
      }); const e = D(R.end, c, F, { handles: b.handles, handleNumber: b.handleNumber }); const f = D('mouseout', c, G, { handles: b.handles, handleNumber: b.handleNumber }); if (c.noUiListeners = d.concat(e, f), a.cursor) { document.body.style.cursor = getComputedStyle(a.target).cursor, Y.length > 1 && j($, da[12]); const g = function () { return !1; }; document.body.noUiListener = g, document.body.addEventListener('selectstart', g, !1); } void 0 !== b.handleNumber && B('start', b.handleNumber);
    } function I(a) { let b; let e; let g = a.calcPoint; let h = 0; return a.stopPropagation(), Y.forEach((a) => { h += c(a)[d.style]; }), b = h / 2 > g || Y.length === 1 ? 0 : 1, Y[b].hasAttribute('disabled') && (b = b ? 0 : 1), g -= c(X)[d.style], e = 100 * g / A(), d.events.snap || f($, da[14], 300), Y[b].hasAttribute('disabled') ? !1 : (L(Y[b], e), B('slide', b, !0), B('set', b, !0), B('change', b, !0), void (d.events.snap && H(a, { handles: [Y[b]] }))); } function J(a) { const b = a.calcPoint - c(X)[d.style]; const e = aa.getStep(100 * b / A()); const f = aa.fromStepping(e); Object.keys(ca).forEach((a) => { a.split('.')[0] === 'hover' && ca[a].forEach((a) => { a.call(Z, f); }); }); } function K(a) { let b; let c; if (!a.fixed) for (b = 0; b < Y.length; b += 1)D(R.start, Y[b].children[0], H, { handles: [Y[b]], handleNumber: b }); if (a.tap && D(R.start, X, I, { handles: Y }), a.hover) for (D(R.move, X, J, { hover: !0 }), b = 0; b < Y.length; b += 1)['mousemove MSPointerMove pointermove'].forEach((a) => { Y[b].children[0].addEventListener(a, n, !1); }); a.drag && (c = [X.querySelector(`.${da[7]}`)], j(c[0], da[10]), a.fixed && c.push(Y[c[0] === Y[0] ? 1 : 0].children[0]), c.forEach((a) => { D(R.start, a, H, { handles: Y }); })); } function L(a, b, c) { const e = a !== Y[0] ? 1 : 0; const f = _[0] + d.margin; const h = _[1] - d.margin; const i = _[0] + d.limit; const l = _[1] - d.limit; return Y.length > 1 && (b = e ? Math.max(b, f) : Math.min(b, h)), c !== !1 && d.limit && Y.length > 1 && (b = e ? Math.min(b, i) : Math.max(b, l)), b = aa.getStep(b), b = g(parseFloat(b.toFixed(7))), b === _[e] ? !1 : (window.requestAnimationFrame ? window.requestAnimationFrame(() => { a.style[d.style] = `${b}%`; }) : a.style[d.style] = `${b}%`, a.previousSibling || (k(a, da[17]), b > 50 && j(a, da[17])), _[e] = b, ba[e] = aa.fromStepping(b), B('update', e), !0); } function M(a, b) { let c; let e; let f; for (d.limit && (a += 1), c = 0; a > c; c += 1)e = c % 2, f = b[e], f !== null && f !== !1 && (typeof f === 'number' && (f = String(f)), f = d.format.from(f), (f === !1 || isNaN(f) || L(Y[e], aa.toStepping(f), c === 3 - d.dir) === !1) && B('update', e)); } function N(a) { let b; let c; const e = h(a); for (d.dir && d.handles > 1 && e.reverse(), d.animate && _[0] !== -1 && f($, da[14], 300), b = Y.length > 1 ? 3 : 1, e.length === 1 && (b = 1), M(b, e), c = 0; c < Y.length; c++)e[c] !== null && B('set', c); } function P() { let a; const b = []; for (a = 0; a < d.handles; a += 1)b[a] = d.format.to(ba[a]); return C(b); } function Q() { for (da.forEach((a) => { a && k($, a); }); $.firstChild;)$.removeChild($.firstChild); delete $.noUiSlider; } function T() { const a = _.map((a, b) => { const c = aa.getApplicableStep(a); const d = i(String(c[2])); const e = ba[b]; const f = a === 100 ? null : c[2]; const g = Number((e - c[2]).toFixed(d)); const h = a === 0 ? null : g >= c[1] ? c[2] : c[0] || !1; return [h, f]; }); return C(a); } function U(a, b) { ca[a] = ca[a] || [], ca[a].push(b), a.split('.')[0] === 'update' && Y.forEach((a, b) => { B('update', b); }); } function V(a) { const b = a.split('.')[0]; const c = a.substring(b.length); Object.keys(ca).forEach((a) => { const d = a.split('.')[0]; const e = a.substring(d.length); b && b !== d || c && c !== e || delete ca[a]; }); } function W(a) {
      let b; const c = P(); const e = O({
        start: [0, 0], margin: a.margin, limit: a.limit, step: a.step, range: a.range, animate: a.animate, snap: void 0 === a.snap ? d.snap : a.snap,
      }); for (['margin', 'limit', 'step', 'range', 'animate'].forEach((b) => { void 0 !== a[b] && (d[b] = a[b]); }), e.spectrum.direction = aa.direction, aa = e.spectrum, _ = [-1, -1], N(c), b = 0; b < Y.length; b++)B('update', b);
    } let X; let Y; let Z; var $ = b; var _ = [-1, -1]; var aa = d.spectrum; var ba = []; var ca = {}; var da = ['target', 'base', 'origin', 'handle', 'horizontal', 'vertical', 'background', 'connect', 'ltr', 'rtl', 'draggable', '', 'state-drag', '', 'state-tap', 'active', '', 'stacking', 'tooltip', '', 'pips', 'marker', 'value'].map(o(d.cssPrefix || S)); if ($.noUiSlider) throw new Error('Slider was already initialized.'); return X = t(d.dir, d.ort, $), Y = s(d.handles, d.dir, X), r(d.connect, $, Y), d.pips && z(d.pips), d.tooltips && v(), Z = {
      destroy: Q, steps: T, on: U, off: V, get: P, set: N, updateOptions: W, options: d, target: $, pips: z,
    }, K(d.events), Z;
  } function Q(a, b) { if (!a.nodeName) throw new Error('noUiSlider.create requires a single element.'); const c = O(b, a); const d = P(a, c); return d.set(c.start), a.noUiSlider = d, d; } var R = window.navigator.pointerEnabled ? { start: 'pointerdown', move: 'pointermove', end: 'pointerup' } : window.navigator.msPointerEnabled ? { start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp' } : { start: 'mousedown touchstart', move: 'mousemove touchmove', end: 'mouseup touchend' }; var S = 'noUi-'; z.prototype.getMargin = function (a) { return this.xPct.length === 2 ? q(this.xVal, a) : !1; }, z.prototype.toStepping = function (a) { return a = u(this.xVal, this.xPct, a), this.direction && (a = 100 - a), a; }, z.prototype.fromStepping = function (a) { return this.direction && (a = 100 - a), e(v(this.xVal, this.xPct, a)); }, z.prototype.getStep = function (a) { return this.direction && (a = 100 - a), a = w(this.xPct, this.xSteps, this.snap, a), this.direction && (a = 100 - a), a; }, z.prototype.getApplicableStep = function (a) { const b = t(a, this.xPct); const c = a === 100 ? 2 : 1; return [this.xNumSteps[b - 2], this.xVal[b - c], this.xNumSteps[b - c]]; }, z.prototype.convert = function (a) { return this.getStep(this.toStepping(a)); }; var T = { to(a) { return void 0 !== a && a.toFixed(2); }, from: Number }; return { create: Q };
}));